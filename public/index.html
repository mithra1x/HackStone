<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Real-Time File Integrity Monitoring</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <div id="root"></div>

  <script type="module">
    const iconMap = {
      create: 'üü¢',
      modify: 'üü°',
      delete: 'üî¥',
      baseline: 'üìê'
    };

    const severityHue = {
      high: 'var(--red)',
      medium: 'var(--amber)',
      info: 'var(--green)'
    };

    const severityWeight = {
      high: 6,
      medium: 3,
      info: 1
    };

    const actionColors = {
      create: 'rgba(34, 197, 94, 0.9)',
      modify: 'rgba(245, 158, 11, 0.9)',
      delete: 'rgba(239, 68, 68, 0.9)'
    };

    const state = {
      events: [],
      status: 'connecting',
      baselineSize: 0,
      alert: ''
    };

    const formatTime = (ts) => new Intl.DateTimeFormat('en', {
      dateStyle: 'medium',
      timeStyle: 'medium'
    }).format(new Date(ts));

    const countersFromEvents = (events) => events.reduce(
      (acc, evt) => {
        if (evt.type === 'create' || evt.type === 'modify' || evt.type === 'delete') {
          acc[evt.type] = (acc[evt.type] || 0) + 1;
        }
        return acc;
      },
      { create: 0, modify: 0, delete: 0 }
    );

    function computeChangesOverTime(events) {
      const windowMs = 24 * 60 * 60 * 1000;
      const hourMs = 60 * 60 * 1000;
      const now = Date.now();
      const windowStart = now - windowMs;
      const buckets = Array.from({ length: 24 }, (_, idx) => {
        const bucketStart = windowStart + idx * hourMs;
        return {
          label: new Intl.DateTimeFormat('en', { hour: '2-digit', hour12: false }).format(new Date(bucketStart)),
          counts: { create: 0, modify: 0, delete: 0 }
        };
      });

      events.forEach((evt) => {
        if (!evt.timestamp) return;
        const ts = new Date(evt.timestamp).getTime();
        if (Number.isNaN(ts) || ts < windowStart || ts > now) return;
        const idx = Math.min(Math.floor((ts - windowStart) / hourMs), buckets.length - 1);
        if (evt.type === 'create' || evt.type === 'modify' || evt.type === 'delete') {
          buckets[idx].counts[evt.type] += 1;
        }
      });

      const maxTotal = Math.max(
        ...buckets.map((b) => Object.values(b.counts).reduce((sum, val) => sum + val, 0)),
        1
      );

      return { buckets, maxTotal };
    }

    function computeRisk(events) {
      const windowMs = 24 * 60 * 60 * 1000;
      const hourMs = 60 * 60 * 1000;
      const now = Date.now();
      const windowStart = now - windowMs;
      const buckets = Array.from({ length: 24 }, (_, idx) => {
        const bucketStart = windowStart + idx * hourMs;
        return {
          label: new Intl.DateTimeFormat('en', { hour: '2-digit', hour12: false }).format(new Date(bucketStart)),
          score: 0,
          actions: 0
        };
      });

      events.forEach((evt) => {
        if (!evt.timestamp || !evt.type) return;
        const ts = new Date(evt.timestamp).getTime();
        if (Number.isNaN(ts) || ts < windowStart || ts > now) return;
        const idx = Math.min(Math.floor((ts - windowStart) / hourMs), buckets.length - 1);
        const weight = severityWeight[evt.severity] || 1;
        const decay = Math.max(0.35, 1 - (now - ts) / windowMs);
        buckets[idx].score += weight * decay;
        buckets[idx].actions += 1;
      });

      const maxScore = Math.max(...buckets.map((b) => b.score), 1);
      const currentScore = buckets[buckets.length - 1]?.score || 0;
      const normalized = Math.min(Math.round((currentScore / maxScore) * 100), 100);
      let label = 'Low';
      let copy = 'Changes look routine with no concentrated destructive activity.';
      if (normalized >= 70) {
        label = 'Critical';
        copy = 'High-risk activity concentrated recently. Validate deletes and rebuild only if trusted.';
      } else if (normalized >= 40) {
        label = 'Elevated';
        copy = 'Steady medium/high severity actions. Review audit trail and confirm operators.';
      }

      return {
        buckets,
        maxScore,
        normalized,
        label,
        copy,
        currentScore
      };
    }

    function pill(label, color) {
      return `<span class="pill" style="background-color:${color}">${label}</span>`;
    }

    function renderEvent(evt) {
      const icon = iconMap[evt.type] || '‚ÑπÔ∏è';
      const mitre = evt.mitre ? pill(`${evt.mitre.id} ¬∑ ${evt.mitre.name}`, 'var(--slate)') : '';
      const severity = evt.severity ? pill(evt.severity.toUpperCase(), severityHue[evt.severity] || 'var(--slate)') : '';
      const beforeHash = evt.beforeHash ? `<span class="hash">Prev: ${evt.beforeHash.slice(0, 10)}‚Ä¶</span>` : '';
      const afterHash = evt.afterHash ? `<span class="hash">New: ${evt.afterHash.slice(0, 10)}‚Ä¶</span>` : '';

      return `
        <div class="event-row">
          <div class="event-icon">${icon}</div>
          <div class="event-body">
            <div class="event-header">
              <div>
                <p class="event-title">${evt.message}</p>
                <p class="event-path">${evt.file || 'Baseline update'}</p>
              </div>
              ${mitre}
            </div>
            <div class="event-meta">
              <span class="timestamp">${formatTime(evt.timestamp)}</span>
              ${beforeHash}
              ${afterHash}
              ${severity}
            </div>
          </div>
        </div>`;
    }

    function renderLegend() {
      return Object.entries(actionColors).map(([type, color]) => `
        <div class="legend-item" key="${type}">
          <span class="legend-swatch" style="background-color:${color}"></span>
          <span class="legend-label">${type}</span>
        </div>
      `).join('');
    }

    function renderChangesChart(model) {
      return model.buckets.map((bucket, idx) => {
        const total = Object.values(bucket.counts).reduce((sum, v) => sum + v, 0);
        const segments = ['create', 'modify', 'delete'].map((type) => {
          const value = bucket.counts[type];
          const height = (value / model.maxTotal) * 100;
          return `<div class="bar-segment" style="height:${height}%;background-color:${actionColors[type]};opacity:${value ? 1 : 0.3}" title="${bucket.label}: ${type} ${value}"></div>`;
        }).join('');
        return `
          <div class="chart-bar" key="${bucket.label}-${idx}">
            <div class="bar-stack" aria-label="Hour ${bucket.label}: ${total} changes">${segments}</div>
            <p class="chart-label">${bucket.label}</p>
          </div>`;
      }).join('');
    }

    function renderRiskChart(risk) {
      return risk.buckets.map((bucket, idx) => {
        const height = (bucket.score / risk.maxScore) * 100;
        return `
          <div class="risk-bar" title="Hour ${bucket.label}: risk score ${bucket.score.toFixed(1)}">
            <div class="risk-bar-fill" style="height:${height}%"></div>
            <p class="chart-label">${bucket.label}</p>
          </div>`;
      }).join('');
    }

    function render() {
      const counters = countersFromEvents(state.events);
      const changesOverTime = computeChangesOverTime(state.events);
      const riskModel = computeRisk(state.events);
      const latest = state.events[0];

      const statusCopy = {
        streaming: 'Live feed active',
        ready: 'Loaded from API',
        connecting: 'Connecting‚Ä¶',
        disconnected: 'Stream disconnected',
        error: 'API unreachable'
      };

      document.getElementById('root').innerHTML = `
        <main class="page">
          <header class="hero">
            <div>
              <p class="eyebrow">Real-time File Integrity Monitoring</p>
              <h1>Trust, but verify every file change</h1>
              <p class="lede">
                Watches a single critical directory, hashes every file, and streams create / modify / delete
                activity with context tied to MITRE ATT&CK-style tactics.
              </p>
              <div class="pill-row">
                ${pill('Hashes are SHA-256', 'var(--slate)')}
                ${pill('Governance filter skips personal data', 'var(--slate)')}
                ${pill('Log integrity via append-only JSONL', 'var(--slate)')}
              </div>
            </div>
          </header>

          ${state.alert ? `<div class="banner">${state.alert}</div>` : ''}

          <div class="toolbar">
            <div>
              <p class="toolbar-title">Secure baseline: ${state.baselineSize} files</p>
              <p class="toolbar-sub">${statusCopy[state.status] || 'Monitoring'}</p>
            </div>
            <button class="btn" id="rebuild-btn">Rebuild baseline</button>
          </div>

          <section class="grid">
            <div class="stat-card"><p class="stat-title">Creates</p><p class="stat-value">${counters.create}</p><p class="stat-hint">New files in scope</p></div>
            <div class="stat-card"><p class="stat-title">Modifications</p><p class="stat-value">${counters.modify}</p><p class="stat-hint">Content tampering</p></div>
            <div class="stat-card"><p class="stat-title">Deletes</p><p class="stat-value">${counters.delete}</p><p class="stat-hint">Potential destruction</p></div>
          </section>

          <section class="chart">
            <div class="chart-head">
              <div>
                <p class="eyebrow">Changes over time (last 24h)</p>
                <h2>Action mix by hour</h2>
              </div>
              <div class="legend">${renderLegend()}</div>
            </div>
            <div class="chart-grid">${renderChangesChart(changesOverTime)}</div>
          </section>

          <section class="risk-card">
            <div class="risk-head">
              <div>
                <p class="eyebrow">AI risk assessment</p>
                <h2>Behavioral risk outlook</h2>
                <p class="risk-sub">Weighted severity with recency decay across the last 24h.</p>
              </div>
              <div class="risk-chip risk-${riskModel.label.toLowerCase()}">
                <span class="risk-chip-score">${riskModel.normalized}</span>
                <span class="risk-chip-text">${riskModel.label}</span>
              </div>
            </div>
            <div class="risk-body">
              <div class="risk-summary">
                <p class="risk-score">${riskModel.normalized}</p>
                <p class="risk-label">${riskModel.label} risk</p>
                <p class="risk-copy">${riskModel.copy}</p>
              </div>
              <div class="risk-chart" role="img" aria-label="Risk score trend over last 24 hours">
                ${renderRiskChart(riskModel)}
              </div>
            </div>
          </section>

          ${latest ? `
            <section class="alert-card">
              <div class="alert-icon">${iconMap[latest.type] || '‚ö†Ô∏è'}</div>
              <div>
                <p class="alert-title">Most recent action</p>
                <p class="alert-body">${latest.message}</p>
                <p class="alert-meta">${formatTime(latest.timestamp)}</p>
              </div>
            </section>` : ''}

          <section class="timeline">
            <div class="timeline-head">
              <h2>Timeline of actions</h2>
              <p class="timeline-sub">Showing up to 200 latest changes</p>
            </div>
            <div class="timeline-list">
              ${state.events.map(renderEvent).join('') || '<p class="empty">No events yet. Touch a file in the watched folder.</p>'}
            </div>
          </section>

          <section class="howto">
            <h3>Operational notes</h3>
            <ul>
              <li>Monitors the <code>watched/</code> directory. Update config in <code>server/index.js</code> if needed.</li>
              <li>Baseline hashes are stored at <code>data/baseline.json</code>. Use the rebuild button after trusted maintenance.</li>
              <li>Logs stream to <code>logs/fim.log</code> using JSON Lines to preserve integrity.</li>
            </ul>
          </section>
        </main>`;

      const rebuildBtn = document.getElementById('rebuild-btn');
      if (rebuildBtn) {
        rebuildBtn.addEventListener('click', async () => {
          state.alert = 'Rebuilding baseline‚Ä¶';
          render();
          try {
            const res = await fetch('/api/rebuild', { method: 'POST' });
            const data = await res.json();
            state.baselineSize = data.baselineSize || 0;
            state.alert = 'Baseline rebuilt';
          } catch (err) {
            state.alert = 'Failed to rebuild baseline';
          }
          setTimeout(() => {
            state.alert = '';
            render();
          }, 2000);
        });
      }
    }

    async function loadInitial() {
      try {
        const res = await fetch('/api/events');
        const data = await res.json();
        state.events = data.events || [];
        state.baselineSize = data.baselineSize || 0;
        state.status = 'ready';
      } catch (err) {
        state.status = 'error';
      }
      render();
    }

    function startStream() {
      const source = new EventSource('/stream');
      source.onopen = () => { state.status = 'streaming'; render(); };
      source.onerror = () => { state.status = 'disconnected'; render(); };
      source.onmessage = (evt) => {
        const payload = JSON.parse(evt.data);
        if (!payload.type || payload.type === 'connected') return;
        state.events.unshift(payload);
        state.events = state.events.slice(0, 200);
        render();
      };
    }

    loadInitial().then(startStream);
  </script>
</body>
</html>
