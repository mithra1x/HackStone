<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Real-Time File Integrity Monitoring</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <div id="root"></div>

  <script type="module">
    const iconMap = {
      create: 'üü¢',
      modify: 'üü°',
      delete: 'üî¥',
      baseline: 'üìê'
    };

    const severityHue = {
      high: 'var(--red)',
      medium: 'var(--amber)',
      info: 'var(--green)'
    };

    const severityWeight = {
      high: 6,
      medium: 3,
      info: 1
    };

    const actionColors = {
      create: 'rgba(34, 197, 94, 0.9)',
      modify: 'rgba(245, 158, 11, 0.9)',
      delete: 'rgba(239, 68, 68, 0.9)'
    };

    const navItems = [
      { id: 'overview', label: 'Overview', icon: 'üìä' },
      { id: 'alertsConsole', label: 'Alerts Console', icon: 'üö®' },
      { id: 'charts', label: 'Charts', icon: 'üìà' },
      { id: 'settings', label: 'Settings', icon: '‚öôÔ∏è' }
    ];

    const timeRangeConfig = {
      '24h': {
        windowMs: 24 * 60 * 60 * 1000,
        bucketMs: 45 * 60 * 1000,
        label: 'last 24 hours',
        bucketLabel: '45-minute buckets',
        labelEvery: 4
      },
      '12h': {
        windowMs: 12 * 60 * 60 * 1000,
        bucketMs: 20 * 60 * 1000,
        label: 'last 12 hours',
        bucketLabel: '20-minute buckets',
        labelEvery: 3
      },
      '1h': {
        windowMs: 60 * 60 * 1000,
        bucketMs: 3 * 60 * 1000,
        label: 'last hour',
        bucketLabel: '3-minute buckets',
        labelEvery: 5
      },
      '15m': {
        windowMs: 15 * 60 * 1000,
        bucketMs: 60 * 1000,
        label: 'last 15 minutes',
        bucketLabel: '1-minute buckets',
        labelEvery: 3
      },
      '5m': {
        windowMs: 5 * 60 * 1000,
        bucketMs: 30 * 1000,
        label: 'last 5 minutes',
        bucketLabel: '30-second buckets',
        labelEvery: 2
      }
    };

    const state = {
      events: [],
      status: 'connecting',
      baselineSize: 0,
      alert: '',
      activeSection: 'overview',
      sidebarOpen: false,
      selectedEvent: null,
      selectedEventForDetails: null,
      eventsFilter: {
        query: '',
        mode: 'path',
        source: 'all',
        agentId: 'all'
      },
      timeRange: '24h',
      timelineScrollTop: 0
    };

    const formatTime = (ts) => new Intl.DateTimeFormat('en', {
      dateStyle: 'medium',
      timeStyle: 'medium'
    }).format(new Date(ts));

    const getMetadata = (evt) => {
      if (!evt) return null;
      const meta = evt.metadata || {};
      return {
        user: meta.user ?? evt.user ?? null,
        uid: meta.uid ?? evt.uid ?? null,
        gid: meta.gid ?? evt.gid ?? null,
        mode: meta.mode ?? evt.mode ?? evt.permissions ?? null,
        size: meta.size ?? evt.size ?? null,
        mtime: meta.mtime ?? evt.mtime ?? null,
        ctime: meta.ctime ?? evt.ctime ?? null
      };
    };

    const countersFromEvents = (events) => events.reduce(
      (acc, evt) => {
        if (evt.type === 'create' || evt.type === 'modify' || evt.type === 'delete') {
          acc[evt.type] = (acc[evt.type] || 0) + 1;
        }
        return acc;
      },
      { create: 0, modify: 0, delete: 0 }
    );

    function computeChangesOverTime(events) {
      const windowMs = 24 * 60 * 60 * 1000;
      const hourMs = 60 * 60 * 1000;
      const now = Date.now();
      const windowStart = now - windowMs;
      const totals = { create: 0, modify: 0, delete: 0 };
      const buckets = Array.from({ length: 24 }, (_, idx) => {
        const bucketStart = windowStart + idx * hourMs;
        return {
          label: new Intl.DateTimeFormat('en', { hour: '2-digit', hour12: false }).format(new Date(bucketStart)),
          counts: { create: 0, modify: 0, delete: 0 }
        };
      });

      events.forEach((evt) => {
        if (!evt.timestamp) return;
        const ts = new Date(evt.timestamp).getTime();
        if (Number.isNaN(ts) || ts < windowStart || ts > now) return;
        const idx = Math.min(Math.floor((ts - windowStart) / hourMs), buckets.length - 1);
        if (evt.type === 'create' || evt.type === 'modify' || evt.type === 'delete') {
          buckets[idx].counts[evt.type] += 1;
          totals[evt.type] += 1;
        }
      });

      const maxTotal = Math.max(
        ...buckets.map((b) => Object.values(b.counts).reduce((sum, val) => sum + val, 0)),
        1
      );

      return { buckets, maxTotal, totals };
    }

    function computeAlertsOverTime(events, rangeKey = '24h') {
      const config = timeRangeConfig[rangeKey] || timeRangeConfig['24h'];
      const windowMs = config.windowMs;
      const bucketMs = config.bucketMs;
      const now = Date.now();
      const start = now - windowMs;
      const labelEvery = Math.max(config.labelEvery || 2, 1);
      const buckets = Array.from({ length: Math.ceil(windowMs / bucketMs) }, (_, idx) => {
        const ts = start + idx * bucketMs;
        const formatOptions = {
          hour: '2-digit',
          minute: bucketMs >= 60 * 60 * 1000 ? undefined : '2-digit',
          hour12: false
        };
        if (bucketMs < 60 * 1000) formatOptions.second = '2-digit';
        const formatter = new Intl.DateTimeFormat('en', formatOptions);
        const bucketStartLabel = formatter.format(new Date(ts));
        const endLabel = formatter.format(new Date(ts + bucketMs));

        return {
          label: bucketStartLabel,
          tooltipLabel: `${bucketStartLabel} ‚Äì ${endLabel}`,
          counts: { create: 0, modify: 0, delete: 0 }
        };
      });

      let maxTotal = 1;
      events.forEach((evt) => {
        if (!evt.timestamp) return;
        const ts = new Date(evt.timestamp).getTime();
        if (Number.isNaN(ts) || ts < start || ts > now) return;
        const idx = Math.min(Math.floor((ts - start) / bucketMs), buckets.length - 1);
        const type = ['create', 'modify', 'delete'].includes(evt.type) ? evt.type : 'modify';
        buckets[idx].counts[type] += 1;
        const total = Object.values(buckets[idx].counts).reduce((sum, val) => sum + val, 0);
        if (total > maxTotal) maxTotal = total;
      });

      return { buckets, maxTotal, windowLabel: config.label, bucketLabel: config.bucketLabel, labelEvery };
    }

    function buildSmoothPath(points) {
      if (!points.length) return '';
      if (points.length === 1) return `M ${points[0].x} ${points[0].y}`;

      const n = points.length;
      const dx = [];
      const dy = [];
      const slopes = new Array(n).fill(0);
      const delta = [];

      for (let i = 0; i < n - 1; i += 1) {
        dx[i] = points[i + 1].x - points[i].x;
        dy[i] = points[i + 1].y - points[i].y;
        delta[i] = dx[i] !== 0 ? dy[i] / dx[i] : 0;
      }

      slopes[0] = delta[0];
      slopes[n - 1] = delta[n - 2];

      for (let i = 1; i < n - 1; i += 1) {
        if (delta[i - 1] * delta[i] <= 0) {
          slopes[i] = 0;
        } else {
          slopes[i] = (delta[i - 1] + delta[i]) / 2;
        }
      }

      for (let i = 0; i < n - 1; i += 1) {
        if (delta[i] === 0) {
          slopes[i] = 0;
          slopes[i + 1] = 0;
        } else {
          const a = slopes[i] / delta[i];
          const b = slopes[i + 1] / delta[i];
          const sum = a * a + b * b;
          if (sum > 9) {
            const t = 3 / Math.sqrt(sum);
            slopes[i] = t * a * delta[i];
            slopes[i + 1] = t * b * delta[i];
          }
        }
      }

      let d = `M ${points[0].x} ${points[0].y}`;
      for (let i = 0; i < n - 1; i += 1) {
        const p0 = points[i];
        const p1 = points[i + 1];
        const h = dx[i];
        const cp1x = p0.x + h / 3;
        const cp1y = p0.y + slopes[i] * h / 3;
        const cp2x = p1.x - h / 3;
        const cp2y = p1.y - slopes[i + 1] * h / 3;
        d += ` C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${p1.x} ${p1.y}`;
      }
      return d;
    }

    function renderAlertsAreaChart(alertsModel) {
      const { buckets, maxTotal, labelEvery } = alertsModel;
      const chartHeight = 260;
      const padding = { top: 16, right: 24, bottom: 32, left: 42 };
      const innerHeight = chartHeight - padding.top - padding.bottom;
      const width = Math.max(640, buckets.length * 38);
      const innerWidth = width - padding.left - padding.right;
      const paddedMax = (() => {
        const raw = Math.max(maxTotal, 1) * 1.2;
        const magnitude = 10 ** Math.floor(Math.log10(raw));
        const rounded = Math.ceil(raw / magnitude * 2) / 2 * magnitude;
        return Math.max(1, Math.round(rounded));
      })();
      const maxVal = paddedMax;
      const step = buckets.length > 1 ? innerWidth / (buckets.length - 1) : innerWidth;
      const series = ['create', 'modify', 'delete'];
      const areaFills = {
        create: 'rgba(34, 197, 94, 0.14)',
        modify: 'rgba(245, 158, 11, 0.14)',
        delete: 'rgba(239, 68, 68, 0.14)'
      };

      const pointsByType = Object.fromEntries(
        series.map((type) => [
          type,
          buckets.map((bucket, idx) => {
            const val = bucket.counts[type] || 0;
            const x = padding.left + idx * step;
            const y = padding.top + (1 - val / maxVal) * innerHeight;
            return { x, y, val, label: bucket.label };
          })
        ])
      );

      const hoverRects = buckets
        .map((bucket, idx) => {
          const x = padding.left + idx * step - step / 2;
          const widthRect = idx === 0 || idx === buckets.length - 1 ? step : step;
          const total = Object.values(bucket.counts).reduce((sum, v) => sum + v, 0);
          const details = series
            .map((type) => `${type}: ${bucket.counts[type] || 0}`)
            .join('  ¬∑  ');
          return `<rect x="${x}" y="${padding.top}" width="${widthRect}" height="${innerHeight}" fill="transparent">
              <title>${bucket.tooltipLabel || bucket.label}\n${details}\nTotal: ${total}</title>
            </rect>`;
        })
        .join('');

      const paths = series
        .map((type) => {
          const pts = pointsByType[type];
          if (!pts.length) return '';
          const line = buildSmoothPath(pts);
          const last = pts[pts.length - 1];
          const first = pts[0];
          const peak = pts.reduce((best, p) => (p.val > best.val ? p : best), pts[0]);
          const area = `${line} L ${last.x} ${padding.top + innerHeight} L ${first.x} ${padding.top + innerHeight} Z`;
          return `
            <g class="area-series">
              <path d="${area}" fill="${areaFills[type]}" />
              <path d="${line}" stroke="${actionColors[type]}" stroke-width="2.4" fill="none" stroke-linejoin="round" stroke-linecap="round" />
              <circle cx="${last.x}" cy="${last.y}" r="4" fill="${actionColors[type]}" stroke="var(--card-bg)" stroke-width="1.4" />
              <circle cx="${last.x}" cy="${last.y}" r="7" fill="none" stroke="${actionColors[type]}" stroke-opacity="0.32" stroke-width="1.6" />
              ${peak.val > 0 ? `<text x="${peak.x}" y="${Math.max(padding.top + 12, peak.y - 12)}" class="peak-label" text-anchor="middle">Peak: ${peak.val}</text>` : ''}
            </g>`;
        })
        .join('');

      const tickCount = 5;
      const stepY = Math.max(1, Math.round(maxVal / (tickCount - 1)));
      const yAxis = Array.from({ length: tickCount }, (_, i) => (i === tickCount - 1 ? maxVal : Math.min(maxVal, stepY * i)));
      const yTicks = yAxis
        .map((tick) => {
          const y = padding.top + (1 - tick / maxVal) * innerHeight;
          return `<g class="axis-tick" transform="translate(0, ${y})">
            <line x1="${padding.left - 6}" x2="${width - padding.right}" y1="0" y2="0" stroke="var(--border)" stroke-width="0.6" stroke-opacity="0.6" />
            <text x="${padding.left - 10}" y="4" text-anchor="end" class="axis-label">${tick}</text>
          </g>`;
        })
        .join('');

      const xLabels = buckets
        .map((bucket, idx) => `<div class="chart-label">${idx % labelEvery === 0 ? bucket.label : ''}</div>`)
        .join('');

      return `
        <div class="alerts-area" role="img" aria-label="Alerts by action over time">
          <svg viewBox="0 0 ${width} ${chartHeight}" preserveAspectRatio="xMidYMid meet">
            <g>${yTicks}</g>
            ${paths}
            <g>${hoverRects}</g>
          </svg>
          <div class="chart-x-labels" style="grid-template-columns: repeat(${buckets.length}, 1fr);">${xLabels}</div>
        </div>
      `;
    }

    function computeRisk(events) {
      const windowMs = 24 * 60 * 60 * 1000;
      const hourMs = 60 * 60 * 1000;
      const now = Date.now();
      const windowStart = now - windowMs;
      const buckets = Array.from({ length: 24 }, (_, idx) => {
        const bucketStart = windowStart + idx * hourMs;
        return {
          label: new Intl.DateTimeFormat('en', { hour: '2-digit', hour12: false }).format(new Date(bucketStart)),
          score: 0,
          actions: 0
        };
      });

      events.forEach((evt) => {
        if (!evt.timestamp || !evt.type) return;
        const ts = new Date(evt.timestamp).getTime();
        if (Number.isNaN(ts) || ts < windowStart || ts > now) return;
        const idx = Math.min(Math.floor((ts - windowStart) / hourMs), buckets.length - 1);
        const weight = severityWeight[evt.severity] || 1;
        const decay = Math.max(0.35, 1 - (now - ts) / windowMs);
        buckets[idx].score += weight * decay;
        buckets[idx].actions += 1;
      });

      const maxScore = Math.max(...buckets.map((b) => b.score), 1);
      const currentScore = buckets[buckets.length - 1]?.score || 0;
      const normalized = Math.min(Math.round((currentScore / maxScore) * 100), 100);
      let label = 'Low';
      let copy = 'Changes look routine with no concentrated destructive activity.';
      if (normalized >= 70) {
        label = 'Critical';
        copy = 'High-risk activity concentrated recently. Validate deletes and rebuild only if trusted.';
      } else if (normalized >= 40) {
        label = 'Elevated';
        copy = 'Steady medium/high severity actions. Review audit trail and confirm operators.';
      }

      return {
        buckets,
        maxScore,
        normalized,
        label,
        copy,
        currentScore
      };
    }

    function pill(label, color) {
      return `<span class="pill" style="background-color:${color}">${label}</span>`;
    }

    function buildEventKey(evt, idx = 0) {
      return evt._key || `${evt.timestamp || 't'}-${evt.path || evt.file || idx}-${evt.type || 'evt'}`;
    }

    function renderEvent(evt, idx) {
      const icon = iconMap[evt.type] || '‚ÑπÔ∏è';
      const mitre = evt.mitre ? pill(`${evt.mitre.id} ¬∑ ${evt.mitre.name}`, 'var(--slate)') : '';
      const severity = evt.severity ? pill(evt.severity.toUpperCase(), severityHue[evt.severity] || 'var(--slate)') : '';
      const ai = evt.aiAssessment || fallbackAiAssessment(evt);
      const eventKey = buildEventKey(evt, idx);

      return `
        <div class="event-row" data-event-id="${eventKey}" tabindex="0" role="button" aria-label="Open details for ${evt.message || 'event'}">
          <div class="event-icon">${icon}</div>
          <div class="event-body">
            <div class="event-header">
              <div>
                <p class="event-title">${evt.message}</p>
                <p class="event-path">${evt.file || 'Baseline update'}</p>
              </div>
              ${mitre}
            </div>
            <div class="event-meta">
              <span class="timestamp">${formatTime(evt.timestamp)}</span>
              ${severity}
              <span class="ai-chip ai-${ai.label.toLowerCase()}">AI: ${ai.label} ¬∑ ${ai.score}</span>
            </div>
            ${renderHashTable(evt.beforeHash, evt.afterHash)}
            ${ai.reason ? `<p class="ai-reason">${ai.reason}</p>` : ''}
          </div>
        </div>`;
    }

    function renderHashTable(beforeHash, afterHash) {
      if (!beforeHash && !afterHash) return '';
      const prevValue = beforeHash ? `<span title="${beforeHash}">${beforeHash}</span>` : '‚Äî';
      const newValue = afterHash ? `<span title="${afterHash}">${afterHash}</span>` : '‚Äî';
      return `
        <div class="hash-table" role="table" aria-label="Previous and new hashes">
          <div class="hash-row hash-head" role="row"><span role="columnheader">Previous hash</span><span role="columnheader">New hash</span></div>
          <div class="hash-row" role="row"><span role="cell">${prevValue}</span><span role="cell">${newValue}</span></div>
        </div>`;
    }

    function fallbackAiAssessment(evt) {
      const severityScore = { high: 72, medium: 52, info: 28 };
      const base = severityScore[evt.severity] || 24;
      let label = 'Stable';
      if (base >= 70) label = 'Critical';
      else if (base >= 55) label = 'Elevated';
      else if (base >= 35) label = 'Watch';
      return { score: base, label, reason: 'derived from severity only' };
    }

    function renderLegend() {
      return Object.entries(actionColors).map(([type, color]) => `
        <div class="legend-item" key="${type}">
          <span class="legend-swatch" style="background-color:${color}"></span>
          <span class="legend-label">${type}</span>
        </div>
      `).join('');
    }

    function renderActionPie(model) {
      const total = Object.values(model.totals).reduce((sum, v) => sum + v, 0);
      if (!total) {
        return '<p class="empty">No changes in the last 24 hours.</p>';
      }

      const orders = ['create', 'modify', 'delete'];
      const toRadians = (pct) => (pct * Math.PI * 2) / 100;
      const arcPath = (start, end) => {
        const radius = 100;
        const sx = radius * Math.cos(start);
        const sy = radius * Math.sin(start);
        const ex = radius * Math.cos(end);
        const ey = radius * Math.sin(end);
        const large = end - start > Math.PI ? 1 : 0;
        return `M ${sx} ${sy} A ${radius} ${radius} 0 ${large} 1 ${ex} ${ey} L 0 0 Z`;
      };

      let cursor = -Math.PI / 2;
      const slices = orders.map((type) => {
        const value = model.totals[type] || 0;
        const pct = (value / total) * 100;
        const end = cursor + toRadians(pct);
        const path = arcPath(cursor, end);
        const mid = cursor + (end - cursor) / 2;
        cursor = end;
        const labelX = 115 * Math.cos(mid);
        const labelY = 115 * Math.sin(mid);
        return { type, value, pct, path, labelX, labelY };
      });

      const legend = slices.map((slice) => `
        <div class="legend-item">
          <span class="legend-swatch" style="background-color:${actionColors[slice.type]}"></span>
          <span class="legend-label">${slice.type} ¬∑ ${Math.round(slice.pct)}%</span>
          <span class="legend-count">(${slice.value})</span>
        </div>`).join('');

      const totalLabel = `${total} change${total === 1 ? '' : 's'} in 24h`;

      return `
        <div class="pie-wrap">
          <div class="pie-chart">
            <svg viewBox="-120 -120 240 240" role="img" aria-label="Action mix pie chart">
              ${slices.map((slice) => `
                <path d="${slice.path}" fill="${actionColors[slice.type]}" fill-opacity="0.88" stroke="rgba(0,0,0,0.25)" stroke-width="1" />
                <text x="${slice.labelX.toFixed(1)}" y="${slice.labelY.toFixed(1)}" fill="var(--text)" font-size="10" text-anchor="middle">${Math.round(slice.pct)}%</text>
              `).join('')}
              <circle r="45" fill="var(--card)" stroke="var(--border)" stroke-width="1" />
            </svg>
            <p class="pie-total">${totalLabel}</p>
          </div>
          <div class="pie-legend">${legend}</div>
        </div>`;
    }

    function renderHourlyLineChart(model) {
      const { buckets, maxTotal } = model;
      const chartHeight = 240;
      const padding = { top: 16, right: 24, bottom: 32, left: 46 };
      const innerHeight = chartHeight - padding.top - padding.bottom;
      const width = Math.max(560, buckets.length * 34);
      const innerWidth = width - padding.left - padding.right;
      const maxVal = Math.max(maxTotal, 1);
      const step = buckets.length > 1 ? innerWidth / (buckets.length - 1) : innerWidth;
      const series = ['create', 'modify', 'delete'];

      const yTicks = Array.from({ length: 5 }, (_, i) => Math.round((maxVal / 4) * i));
      const yGrid = yTicks
        .map((tick) => {
          const y = padding.top + (1 - tick / maxVal) * innerHeight;
          return `<g class="axis-tick" transform="translate(0, ${y})">
              <line x1="${padding.left}" x2="${width - padding.right}" y1="0" y2="0" stroke="var(--border)" stroke-width="0.6" stroke-dasharray="4 4" />
              <text x="${padding.left - 10}" y="4" text-anchor="end" class="axis-label">${tick}</text>
            </g>`;
        })
        .join('');

      const xLabels = buckets
        .map((bucket, idx) => `<div class="chart-label">${idx % 2 === 0 ? bucket.label : ''}</div>`)
        .join('');

      const lines = series
        .map((type) => {
          const points = buckets.map((bucket, idx) => {
            const val = bucket.counts[type] || 0;
            const x = padding.left + idx * step;
            const y = padding.top + (1 - val / maxVal) * innerHeight;
            return { x, y, val, label: bucket.label };
          });
          if (!points.length) return '';
          const line = buildSmoothPath(points);
          const dots = points
            .map((pt) => `<circle cx="${pt.x}" cy="${pt.y}" r="3.5" fill="${actionColors[type]}" opacity="0.9"><title>${pt.label} ¬∑ ${type}: ${pt.val}</title></circle>`)
            .join('');
          return `
            <g class="line-series">
              <path d="${line}" fill="none" stroke="${actionColors[type]}" stroke-width="2.4" stroke-linecap="round" stroke-linejoin="round" />
              ${dots}
            </g>`;
        })
        .join('');

      return `
        <div class="line-chart" role="img" aria-label="Changes by hour line chart">
          <svg viewBox="0 0 ${width} ${chartHeight}" preserveAspectRatio="xMidYMid meet">
            <g>${yGrid}</g>
            ${lines}
          </svg>
          <div class="chart-x-labels" style="grid-template-columns: repeat(${buckets.length}, 1fr);">${xLabels}</div>
        </div>
      `;
    }

    function renderRiskChart(risk) {
      return risk.buckets.map((bucket, idx) => {
        const height = (bucket.score / risk.maxScore) * 100;
        return `
          <div class="risk-bar" title="Hour ${bucket.label}: risk score ${bucket.score.toFixed(1)}">
            <div class="risk-bar-fill" style="height:${height}%"></div>
            <p class="chart-label">${bucket.label}</p>
          </div>`;
      }).join('');
    }

    function getFilteredEvents() {
      const search = state.eventsFilter.query.trim().toLowerCase();
      const mode = state.eventsFilter.mode || 'path';
      const sourceFilter = state.eventsFilter.source || 'all';
      const agentFilter = state.eventsFilter.agentId || 'all';
      const range = timeRangeConfig[state.timeRange]?.windowMs || timeRangeConfig['24h'].windowMs;
      const now = Date.now();

      return state.events
        .filter((evt) => {
          const ts = evt.timestamp ? new Date(evt.timestamp).getTime() : now;
          if (Number.isNaN(ts) || now - ts > range) return false;
          if (sourceFilter === 'local') return evt.source === 'local';
          if (sourceFilter === 'agent') return evt.source === 'agent';
          return true;
        })
        .filter((evt) => {
          if (sourceFilter !== 'agent' || agentFilter === 'all') return true;
          return (evt.agentId || null) === agentFilter;
        })
        .filter((evt) => {
          if (!search) return true;
          if (mode === 'action') {
            return (evt.type || '').toLowerCase().includes(search);
          }
          if (mode === 'severity') {
            return (evt.severity || '').toLowerCase().includes(search);
          }
          return (
            (evt.file && evt.file.toLowerCase().includes(search)) ||
            (evt.path && evt.path.toLowerCase().includes(search)) ||
            (evt.message && evt.message.toLowerCase().includes(search)) ||
            (evt.description && evt.description.toLowerCase().includes(search))
          );
        })
        .slice(0, 100)
        .map((evt, idx) => ({
          ...evt,
          _key: evt._key || `${evt.timestamp || 't'}-${evt.path || evt.file || idx}-${evt.type || 'evt'}`
        }));
    }

    function getAgentOptions() {
      const range = timeRangeConfig[state.timeRange]?.windowMs || timeRangeConfig['24h'].windowMs;
      const now = Date.now();
      const ids = new Set();

      state.events.forEach((evt) => {
        const ts = evt.timestamp ? new Date(evt.timestamp).getTime() : now;
        if (Number.isNaN(ts) || now - ts > range) return;
        if (evt.source !== 'agent' || !evt.agentId) return;
        ids.add(evt.agentId);
      });

      return Array.from(ids);
    }

    function formatEventSource(evt) {
      if (evt?.source === 'agent') {
        return evt.agentId ? `agent: ${evt.agentId}` : 'agent';
      }
      if (evt?.source === 'local') return 'local';
      return evt?.source || 'local';
    }

    function renderAlertsConsoleSection(alertsModel, filteredEvents, rangeKey) {
      const selected = state.selectedEvent || filteredEvents[0];
      const latestPath = selected?.file || selected?.path || 'Select an event from the list to see details.';
      const rangeLabel = alertsModel.windowLabel || 'last 24 hours';
      const bucketLabel = alertsModel.bucketLabel || 'time buckets';
      const filterModeLabel =
        state.eventsFilter.mode === 'action'
          ? 'action'
          : state.eventsFilter.mode === 'severity'
            ? 'severity'
            : 'path';
      const agentOptions = getAgentOptions();
      const showAgentFilter = state.eventsFilter.source === 'agent' && agentOptions.length > 0;
      const detailRows = selected
        ? [
            ['Path', latestPath],
            ['Observed', selected?.timestamp ? formatTime(selected.timestamp) : '‚Äî'],
            ['Action', selected?.type || '‚Äî'],
            ['User', selected?.user || selected?.uid || '‚Äî'],
            ['Group', selected?.group || selected?.gid || '‚Äî'],
            ['Permissions', selected?.permissions || '‚Äî'],
            ['Size', selected?.size ? `${selected.size} bytes` : '‚Äî'],
            ['Hash', selected?.hash || selected?.sha256 || '‚Äî'],
            ['Severity', selected?.severity || '‚Äî'],
            ['Classification', selected?.data_classification || '‚Äî'],
            ['Tags', selected?.tags?.join?.(', ') || '‚Äî'],
            ['Rule', selected?.rule_id || '‚Äî'],
            ['MITRE', selected?.mitre?.map?.((m) => `${m.technique_id || m.id || m.name} (${m.tactic || m.name || ''})`).join(', ') || '‚Äî']
          ]
        : [];

      return `
        <div class="stack gap-4">
          <section class="card alerts-chart">
            <div class="flex items-center justify-between">
              <div>
                <p class="eyebrow">Live view</p>
                <h2 class="title-lg">Alerts by action over time</h2>
                <p class="text-muted">Stacked counts over the ${rangeLabel} using ${bucketLabel}.</p>
              </div>
              <div class="flex items-center gap-4">
                <div class="flex items-center gap-2">
                  <label for="alerts-range" class="text-muted">Range</label>
                  <select class="select range-select" id="alerts-range">
                    <option value="24h" ${rangeKey === '24h' ? 'selected' : ''}>24h</option>
                    <option value="12h" ${rangeKey === '12h' ? 'selected' : ''}>12h</option>
                    <option value="1h" ${rangeKey === '1h' ? 'selected' : ''}>1h</option>
                    <option value="15m" ${rangeKey === '15m' ? 'selected' : ''}>15m</option>
                    <option value="5m" ${rangeKey === '5m' ? 'selected' : ''}>5m</option>
                  </select>
                </div>
                <div class="legend">${renderLegend()}</div>
              </div>
            </div>
            ${renderAlertsAreaChart(alertsModel)}
          </section>

          <div class="alerts-grid">
            <section class="card details-card">
              <div class="flex items-center justify-between">
                <h3 class="title-sm">Details</h3>
                ${selected ? `<span class="pill">${selected?.severity || 'info'}</span>` : ''}
              </div>
              ${selected
                ? `
                  <p class="text-muted">${selected?.message || 'File event'}</p>
                  <div class="details-grid">
                    ${detailRows
                      .map(
                        ([label, value]) => `
                          <div class="detail-item">
                            <p class="detail-label">${label}</p>
                            <p class="detail-value">${value}</p>
                          </div>`
                      )
                      .join('')}
                  </div>
                `
                : '<p class="empty">Select an event from the list to see details.</p>'}
            </section>

            <section class="card events-card">
              <div class="flex items-center justify-between">
                <h3 class="title-sm">Recent events</h3>
                <div class="flex items-center gap-4">
                  <select class="select mode-select" id="events-mode">
                    <option value="path" ${state.eventsFilter.mode === 'path' ? 'selected' : ''}>Path</option>
                    <option value="action" ${state.eventsFilter.mode === 'action' ? 'selected' : ''}>Action</option>
                    <option value="severity" ${state.eventsFilter.mode === 'severity' ? 'selected' : ''}>Severity</option>
                  </select>
                  <select class="select mode-select" id="events-source">
                    <option value="all" ${state.eventsFilter.source === 'all' ? 'selected' : ''}>All sources</option>
                    <option value="local" ${state.eventsFilter.source === 'local' ? 'selected' : ''}>Local</option>
                    <option value="agent" ${state.eventsFilter.source === 'agent' ? 'selected' : ''}>Agent</option>
                  </select>
                  ${
                    showAgentFilter
                      ? `<select class="select mode-select" id="events-agent">
                          <option value="all" ${state.eventsFilter.agentId === 'all' ? 'selected' : ''}>All agents</option>
                          ${agentOptions
                            .map(
                              (agent) => `<option value="${agent}" ${state.eventsFilter.agentId === agent ? 'selected' : ''}>${agent}</option>`
                            )
                            .join('')}
                        </select>`
                      : ''
                  }
                  <input class="input" id="events-search" type="search" placeholder="Search by ${filterModeLabel}" value="${state.eventsFilter.query}" />
                  <select class="select range-select" id="events-range">
                    <option value="24h" ${state.timeRange === '24h' ? 'selected' : ''}>Last 24h</option>
                    <option value="12h" ${state.timeRange === '12h' ? 'selected' : ''}>Last 12h</option>
                    <option value="1h" ${state.timeRange === '1h' ? 'selected' : ''}>Last hour</option>
                    <option value="15m" ${state.timeRange === '15m' ? 'selected' : ''}>Last 15m</option>
                    <option value="5m" ${state.timeRange === '5m' ? 'selected' : ''}>Last 5m</option>
                  </select>
                  <button class="btn ghost" id="events-refresh">Refresh</button>
                </div>
              </div>
              <div class="events-table" role="table">
                <div class="events-head" role="row">
                  <span>Time</span><span>Action</span><span>Description</span><span>Severity</span><span>Source</span><span>Rule</span>
                </div>
                <div class="events-body" role="rowgroup">
                  ${filteredEvents
                    .map((evt, idx) => {
                      const isActive = selected && (selected === evt || selected._key === evt._key);
                      return `
                        <button class="event-row-btn ${isActive ? 'active' : ''}" data-event-index="${idx}" role="row">
                          <span>${evt.timestamp ? formatTime(evt.timestamp) : '‚Äî'}</span>
                          <span class="flex items-center gap-2"><span class="pill compact">${evt.type || 'info'}</span>${evt.file || evt.path || '‚Äî'}</span>
                          <span class="truncate">${evt.message || evt.description || 'File event'}</span>
                          <span>${evt.severity || 'info'}</span>
                          <span>${formatEventSource(evt)}</span>
                          <span>${evt.rule_id || '‚Äî'}</span>
                        </button>`;
                    })
                    .join('') || '<p class="empty">No events available.</p>'}
                </div>
              </div>
            </section>
          </div>
        </div>
      `;
    }

    function renderOverviewSection(counters, statusCopy, latest) {
      return `
        <div class="stack gap-4">
          <div class="card-grid">
            <header class="hero card">
              <div>
                <p class="eyebrow">Real-time File Integrity Monitoring</p>
                <h1>Trust, but verify every file change</h1>
                <p class="lede">
                  Watches a single critical directory, hashes every file, and streams create / modify / delete
                  activity with context tied to MITRE ATT&CK-style tactics.
                </p>
                <div class="pill-row">
                  ${pill('Hashes are SHA-256', 'var(--slate)')}
                  ${pill('Governance filter skips personal data', 'var(--slate)')}
                  ${pill('Log integrity via append-only JSONL', 'var(--slate)')}
                </div>
              </div>
            </header>

            <div class="card summary-side">
              ${state.alert ? `<div class="banner">${state.alert}</div>` : ''}
              <div class="toolbar">
                <div>
                  <p class="toolbar-title">Secure baseline: ${state.baselineSize} files</p>
                  <p class="toolbar-sub">${statusCopy[state.status] || 'Monitoring'}</p>
                </div>
                <button class="btn" id="rebuild-btn">Rebuild baseline</button>
              </div>
              <section class="grid stats-grid">
                <div class="stat-card"><p class="stat-title">Creates</p><p class="stat-value">${counters.create}</p><p class="stat-hint">New files in scope</p></div>
                <div class="stat-card"><p class="stat-title">Modifications</p><p class="stat-value">${counters.modify}</p><p class="stat-hint">Content tampering</p></div>
                <div class="stat-card"><p class="stat-title">Deletes</p><p class="stat-value">${counters.delete}</p><p class="stat-hint">Potential destruction</p></div>
              </section>
            </div>
          </div>

          <div class="stack gap-4">
            ${latest ? `
              <section class="alert-card card">
                <div class="alert-icon">${iconMap[latest.type] || '‚ö†Ô∏è'}</div>
                <div>
                  <p class="alert-title">Most recent action</p>
                  <p class="alert-body">${latest.message}</p>
                  <p class="alert-meta">${formatTime(latest.timestamp)}</p>
                </div>
              </section>` : ''}

            <section class="timeline card">
              <div class="timeline-head">
                <h2>Timeline of actions</h2>
                <p class="timeline-sub">Showing up to 200 latest changes</p>
              </div>
              <div class="timeline-list">
                ${state.events.map((evt, idx) => renderEvent(evt, idx)).join('') || '<p class="empty">No events yet. Touch a file in the watched folder.</p>'}
              </div>
            </section>
          </div>
        </div>
      `;
    }

    function renderEventDetailsSection(evt) {
      const ai = evt ? evt.aiAssessment || fallbackAiAssessment(evt) : null;
      const mitreEntries = evt?.mitre ? (Array.isArray(evt.mitre) ? evt.mitre : [evt.mitre]) : [];
      const mitreValue =
        mitreEntries.length > 0
          ? mitreEntries
              .map((m) => `${m.technique_id || m.id || '‚Äî'}${m.tactic ? ` ¬∑ ${m.tactic}` : ''}${m.name ? ` ¬∑ ${m.name}` : ''}`)
              .join(', ')
          : '‚Äî';

      const metadataSection = renderMetadataSection(evt);

      const details = evt
        ? [
            ['File path', evt.file || evt.path || '‚Äî'],
            ['Observed time', evt.timestamp ? formatTime(evt.timestamp) : '‚Äî'],
            ['Action', evt.type || '‚Äî'],
            ['Source', evt.source || '‚Äî'],
            ['Agent', evt.agentId || '‚Äî'],
            ['SHA-256', evt.sha256 || evt.hash || evt.afterHash || '‚Äî'],
            ['MD5', evt.md5 || '‚Äî'],
            ['Classification / tags', evt.data_classification || evt.tags?.join?.(', ') || '‚Äî'],
            ['MITRE mapping', mitreValue],
            ['AI risk score', ai ? `${ai.label} ¬∑ ${ai.score}` : '‚Äî'],
            ['Previous hash', evt.beforeHash || '‚Äî'],
            ['New hash', evt.afterHash || '‚Äî'],
            ['Baseline', evt.baseline ? 'Baseline update' : '‚Äî'],
            ['Rule', evt.rule_id || '‚Äî']
          ]
        : [];

      return `
        <div class="stack gap-4">
          <section class="card event-details">
            <div class="event-details-top">
              <button class="btn ghost" id="back-to-overview">‚Üê Back to Overview</button>
              <div class="event-details-header">
                <div>
                  <p class="eyebrow">Event Details</p>
                  <h2 class="title-lg">${evt?.file || evt?.path || 'No event selected'}</h2>
                  <p class="text-muted">${evt?.timestamp ? formatTime(evt.timestamp) : 'Select a timeline event to view details'}</p>
                </div>
                <div class="details-chips">
                  ${evt?.type ? pill(evt.type.toUpperCase(), actionColors[evt.type] || 'var(--slate)') : ''}
                  ${evt?.severity ? pill(evt.severity.toUpperCase(), severityHue[evt.severity] || 'var(--slate)') : ''}
                  ${evt?.timestamp ? pill('Observed', 'var(--slate)') : ''}
                  ${ai ? `<span class="ai-chip ai-${ai.label.toLowerCase()}">AI: ${ai.label} ¬∑ ${ai.score}</span>` : ''}
                </div>
              </div>
            </div>
            <div class="detail-grid">
              ${details
            .map(
              ([label, value]) => `
                <div class="detail-tile">
                  <p class="detail-label">${label}</p>
                  <p class="detail-value">${value}</p>
                </div>`
            )
            .join('') || '<p class="empty">No event selected.</p>'}
            </div>
            ${metadataSection}
            ${evt ? renderHashTable(evt.beforeHash, evt.afterHash) : ''}
            ${ai?.reason ? `<p class="ai-reason">${ai.reason}</p>` : ''}
          </section>
        </div>
      `;
    }

    function renderMetadataSection(evt) {
      if (!evt) return '';
      const meta = getMetadata(evt) || {};
      const formatOrNA = (value) => (value === null || value === undefined || value === '' ? 'N/A' : value);
      const rows = [
        ['User', formatOrNA(meta.user)],
        ['UID', formatOrNA(meta.uid)],
        ['GID', formatOrNA(meta.gid)],
        ['Permissions', formatOrNA(meta.mode)],
        [
          'File size',
          meta.size === null || meta.size === undefined
            ? 'N/A'
            : `${Number(meta.size).toLocaleString('en-US')} bytes`
        ],
        ['Modified time', meta.mtime ? formatTime(meta.mtime) : 'N/A'],
        ['Change time', meta.ctime ? formatTime(meta.ctime) : 'N/A']
      ];

      return `
        <div class="metadata-section">
          <div class="metadata-head">
            <p class="eyebrow">File Metadata</p>
            <h3 class="title-md">Filesystem attributes</h3>
          </div>
          <div class="metadata-grid">
            ${rows
              .map(
                ([label, value]) => `
                  <div class="metadata-item">
                    <p class="detail-label">${label}</p>
                    <p class="detail-value">${value}</p>
                  </div>`
              )
              .join('')}
          </div>
        </div>
      `;
    }

    function renderChartsSection(changesOverTime, riskModel) {
      return `
        <div class="stack gap-4">
          <section class="chart card">
            <div class="chart-head">
              <div>
                <p class="eyebrow">Changes over time (last 24h)</p>
                <h2>Action mix</h2>
                <p class="chart-subtitle">Share of create / modify / delete events in the last 24 hours</p>
              </div>
              <div class="legend">${renderLegend()}</div>
            </div>
            <div class="chart-split">
              <div class="pie-area">
                <p class="chart-subtitle">Overall distribution</p>
                ${renderActionPie(changesOverTime)}
              </div>
              <div class="hourly-area">
                <div class="chart-head-sub">
                  <p class="eyebrow">Hourly breakdown</p>
                  <h3>Changes by hour</h3>
                  <p class="chart-subtitle">Smoothed lines for create / modify / delete trends</p>
                </div>
                <div class="chart-line-wrap">${renderHourlyLineChart(changesOverTime)}</div>
              </div>
            </div>
          </section>

          <section class="risk-card card">
            <div class="risk-head">
              <div>
                <p class="eyebrow">AI risk assessment</p>
                <h2>Behavioral risk outlook</h2>
                <p class="risk-sub">Weighted severity with recency decay across the last 24h.</p>
              </div>
              <div class="risk-chip risk-${riskModel.label.toLowerCase()}">
                <span class="risk-chip-score">${riskModel.normalized}</span>
                <span class="risk-chip-text">${riskModel.label}</span>
              </div>
            </div>
            <div class="risk-body">
              <div class="risk-summary">
                <p class="risk-score">${riskModel.normalized}</p>
                <p class="risk-label">${riskModel.label} risk</p>
                <p class="risk-copy">${riskModel.copy}</p>
              </div>
              <div class="risk-chart" role="img" aria-label="Risk score trend over last 24 hours">
                ${renderRiskChart(riskModel)}
              </div>
            </div>
          </section>
        </div>
      `;
    }

    function renderSettingsSection(statusCopy) {
      return `
        <div class="stack gap-4">
          <div class="card">
            <div class="flex items-center justify-between">
              <div>
                <p class="eyebrow">Monitoring status</p>
                <h2 class="title-lg">${statusCopy[state.status] || 'Monitoring'}</h2>
                <p class="text-muted">Adjust operational controls and recovery actions.</p>
              </div>
              <button class="btn" id="rebuild-btn">Rebuild baseline</button>
            </div>
          </div>
          <div class="grid stats-grid">
            <div class="stat-card"><p class="stat-title">Notifications</p><p class="stat-value">On deck</p><p class="stat-hint">Add webhook targets</p></div>
            <div class="stat-card"><p class="stat-title">Scope</p><p class="stat-value">watched/</p><p class="stat-hint">Single critical directory</p></div>
            <div class="stat-card"><p class="stat-title">Retention</p><p class="stat-value">24h view</p><p class="stat-hint">Event window for charts</p></div>
          </div>
        </div>
      `;
    }

    function renderMain(activeSection, counters, statusCopy, changesOverTime, riskModel, latest, filteredEvents) {
      switch (activeSection) {
        case 'alertsConsole':
          return renderAlertsConsoleSection(
            computeAlertsOverTime(filteredEvents || [], state.timeRange),
            filteredEvents || getFilteredEvents(),
            state.timeRange
          );
        case 'charts':
          return renderChartsSection(changesOverTime, riskModel);
        case 'settings':
          return renderSettingsSection(statusCopy);
        case 'eventDetails':
          return renderEventDetailsSection(state.selectedEventForDetails);
        case 'overview':
        default:
          return renderOverviewSection(counters, statusCopy, latest);
      }
    }

    function renderSidebar() {
      return `
        <aside class="sidebar ${state.sidebarOpen ? 'open' : ''}">
          <div class="sidebar-header">
            <div class="logo-mark">üõ°Ô∏è</div>
            <div>
              <p class="logo-title">HackStone</p>
              <p class="logo-sub">FIM Dashboard</p>
            </div>
          </div>
          <nav class="sidebar-nav">
            ${navItems.map((item) => `
              <button class="nav-item ${state.activeSection === item.id ? 'active' : ''}" data-section="${item.id}">
                <span class="nav-icon">${item.icon}</span>
                <span>${item.label}</span>
              </button>
            `).join('')}
          </nav>
        </aside>
      `;
    }

    function render() {
      const activeElement = document.activeElement;
      const searchHadFocus = activeElement?.id === 'events-search';
      const searchSelection = searchHadFocus
        ? { start: activeElement.selectionStart, end: activeElement.selectionEnd }
        : null;
      const counters = countersFromEvents(state.events);
      const changesOverTime = computeChangesOverTime(state.events);
      const riskModel = computeRisk(state.events);
      const latest = state.events[0];
      const filteredEvents = state.activeSection === 'alertsConsole' ? getFilteredEvents() : null;
      const activeLabel =
        state.activeSection === 'eventDetails'
          ? 'Event Details'
          : navItems.find((n) => n.id === state.activeSection)?.label || 'Overview';

      if (state.activeSection === 'alertsConsole') {
        if (!filteredEvents?.length) {
          state.selectedEvent = null;
        } else if (!state.selectedEvent || !filteredEvents.some((evt) => evt._key === state.selectedEvent._key)) {
          state.selectedEvent = filteredEvents[0];
        }
      }

      const statusCopy = {
        streaming: 'Live feed active',
        ready: 'Loaded from API',
        connecting: 'Connecting‚Ä¶',
        disconnected: 'Stream disconnected',
        error: 'API unreachable'
      };

      document.getElementById('root').innerHTML = `
        <div class="app-shell">
          ${renderSidebar()}
          <div class="shell-main">
            <header class="topbar">
              <button class="hamburger" id="hamburger-btn" aria-label="Toggle navigation">
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
              </button>
              <div>
                <p class="eyebrow">${activeLabel}</p>
                <h2 class="title-lg">${activeLabel}</h2>
              </div>
            </header>
            <main class="main-content">
              ${renderMain(state.activeSection, counters, statusCopy, changesOverTime, riskModel, latest, filteredEvents)}
            </main>
          </div>
          <div class="sidebar-backdrop ${state.sidebarOpen ? 'visible' : ''}" id="sidebar-backdrop"></div>
        </div>`;

      if (searchHadFocus) {
        const searchInput = document.getElementById('events-search');
        if (searchInput) {
          searchInput.focus();
          if (searchSelection && typeof searchSelection.start === 'number' && typeof searchSelection.end === 'number') {
            searchInput.setSelectionRange(searchSelection.start, searchSelection.end);
          }
        }
      }

      const rebuildBtn = document.getElementById('rebuild-btn');
      if (rebuildBtn) {
        rebuildBtn.addEventListener('click', async () => {
          state.alert = 'Rebuilding baseline‚Ä¶';
          render();
          try {
            const res = await fetch('/api/rebuild', { method: 'POST' });
            const data = await res.json();
            state.baselineSize = data.baselineSize || 0;
            state.alert = 'Baseline rebuilt';
          } catch (err) {
            state.alert = 'Failed to rebuild baseline';
          }
          setTimeout(() => {
            state.alert = '';
            render();
          }, 2000);
        });
      }

      const navButtons = document.querySelectorAll('.nav-item');
      navButtons.forEach((btn) => {
        btn.addEventListener('click', () => {
          const target = btn.getAttribute('data-section');
          state.activeSection = target;
          if (window.innerWidth < 768) state.sidebarOpen = false;
          render();
        });
      });

      const hamburger = document.getElementById('hamburger-btn');
      if (hamburger) {
        hamburger.addEventListener('click', () => {
          state.sidebarOpen = !state.sidebarOpen;
          render();
        });
      }

      const backdrop = document.getElementById('sidebar-backdrop');
      if (backdrop) {
        backdrop.addEventListener('click', () => {
          state.sidebarOpen = false;
          render();
        });
      }

      if (state.activeSection === 'alertsConsole') {
        const searchInput = document.getElementById('events-search');
        if (searchInput) {
          searchInput.addEventListener('input', (e) => {
            state.eventsFilter.query = e.target.value;
            render();
          });
        }

        const modeSelect = document.getElementById('events-mode');
        if (modeSelect) {
          modeSelect.addEventListener('change', (e) => {
            state.eventsFilter.mode = e.target.value;
            render();
          });
        }

        const sourceSelect = document.getElementById('events-source');
        if (sourceSelect) {
          sourceSelect.addEventListener('change', (e) => {
            state.eventsFilter.source = e.target.value;
            state.eventsFilter.agentId = 'all';
            render();
          });
        }

        const agentSelect = document.getElementById('events-agent');
        if (agentSelect) {
          agentSelect.addEventListener('change', (e) => {
            state.eventsFilter.agentId = e.target.value;
            render();
          });
        }

        const rangeSelects = document.querySelectorAll('.range-select');
        rangeSelects.forEach((select) => {
          select.addEventListener('change', (e) => {
            state.timeRange = e.target.value;
            render();
          });
        });

        const refreshBtn = document.getElementById('events-refresh');
        if (refreshBtn) {
          refreshBtn.addEventListener('click', async () => {
            await refreshEvents();
            render();
          });
        }

        const rows = document.querySelectorAll('.event-row-btn');
        const currentList = filteredEvents || getFilteredEvents();
        rows.forEach((row) => {
          row.addEventListener('click', () => {
            const idx = Number(row.getAttribute('data-event-index'));
            state.selectedEvent = currentList[idx];
            render();
          });
        });
      }

      if (state.activeSection === 'overview') {
        const keyMap = state.events.reduce((acc, evt, idx) => {
          acc[buildEventKey(evt, idx)] = evt;
          return acc;
        }, {});
        const timelineRows = document.querySelectorAll('.timeline-list .event-row');
        const timelineList = document.querySelector('.timeline-list');
        if (timelineList && typeof state.timelineScrollTop === 'number') {
          timelineList.scrollTop = state.timelineScrollTop;
        }
        timelineRows.forEach((row) => {
          const evt = keyMap[row.getAttribute('data-event-id')];
          if (!evt) return;
          const activate = () => {
            const listEl = document.querySelector('.timeline-list');
            state.timelineScrollTop = listEl?.scrollTop || 0;
            state.selectedEventForDetails = evt;
            state.activeSection = 'eventDetails';
            render();
          };
          row.addEventListener('click', activate);
          row.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              activate();
            }
          });
        });
      }

      if (state.activeSection === 'eventDetails') {
        const backBtn = document.getElementById('back-to-overview');
        if (backBtn) {
          backBtn.addEventListener('click', () => {
            state.activeSection = 'overview';
            state.selectedEventForDetails = null;
            render();
          });
        }
      }
    }

    async function loadInitial() {
      try {
        const res = await fetch('/api/events');
        const data = await res.json();
        state.events = data.events || [];
        state.baselineSize = data.baselineSize || 0;
        state.status = 'ready';
      } catch (err) {
        state.status = 'error';
      }
      render();
    }

    async function refreshEvents() {
      try {
        const res = await fetch('/api/events');
        const data = await res.json();
        state.events = data.events || [];
      } catch (err) {
        state.status = 'error';
      }
    }

    function startStream() {
      const source = new EventSource('/stream');
      source.onopen = () => { state.status = 'streaming'; render(); };
      source.onerror = () => { state.status = 'disconnected'; render(); };
      source.onmessage = (evt) => {
        const payload = JSON.parse(evt.data);
        if (!payload.type || payload.type === 'connected') return;
        state.events.unshift(payload);
        state.events = state.events.slice(0, 200);
        render();
      };
    }

    loadInitial().then(startStream);
  </script>
</body>
</html>
