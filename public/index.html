<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Real-Time File Integrity Monitoring</title>
  <link rel="stylesheet" href="/styles.css" />
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useState } = React;

    const iconMap = {
      create: 'üü¢',
      modify: 'üü°',
      delete: 'üî¥',
      baseline: 'üìê'
    };

    const severityHue = {
      high: 'var(--red)',
      medium: 'var(--amber)',
      info: 'var(--green)'
    };

    const actionColors = {
      create: 'rgba(34, 197, 94, 0.9)',
      modify: 'rgba(245, 158, 11, 0.9)',
      delete: 'rgba(239, 68, 68, 0.9)'
    };

    const formatTime = (ts) => new Intl.DateTimeFormat('en', {
      dateStyle: 'medium',
      timeStyle: 'medium'
    }).format(new Date(ts));

    function useFimEvents() {
      const [events, setEvents] = useState([]);
      const [status, setStatus] = useState('connecting');
      const [baselineSize, setBaselineSize] = useState(0);

      useEffect(() => {
        fetch('/api/events')
          .then((res) => res.json())
          .then((data) => {
            setEvents(data.events || []);
            setBaselineSize(data.baselineSize || 0);
            setStatus('ready');
          })
          .catch(() => setStatus('error'));

        const source = new EventSource('/stream');
        source.onopen = () => setStatus('streaming');
        source.onerror = () => setStatus('disconnected');
        source.onmessage = (evt) => {
          const payload = JSON.parse(evt.data);
          if (!payload.type || payload.type === 'connected') return;
          setEvents((prev) => [payload, ...prev].slice(0, 200));
        };
        return () => source.close();
      }, []);

      const counters = useMemo(() => {
        return events.reduce(
          (acc, evt) => {
            acc[evt.type] = (acc[evt.type] || 0) + 1;
            return acc;
          },
          { create: 0, modify: 0, delete: 0 }
        );
      }, [events]);

      return { events, status, counters, baselineSize, setEvents, setBaselineSize };
    }

    function Pill({ label, color }) {
      return <span className="pill" style={{ backgroundColor: color }}>{label}</span>;
    }

    function StatCard({ title, value, hint }) {
      return (
        <div className="stat-card">
          <p className="stat-title">{title}</p>
          <p className="stat-value">{value}</p>
          {hint && <p className="stat-hint">{hint}</p>}
        </div>
      );
    }

    function EventRow({ evt }) {
      const icon = iconMap[evt.type] || '‚ÑπÔ∏è';
      return (
        <div className="event-row">
          <div className="event-icon">{icon}</div>
          <div className="event-body">
            <div className="event-header">
              <div>
                <p className="event-title">{evt.message}</p>
                <p className="event-path">{evt.file || 'Baseline update'}</p>
              </div>
              {evt.mitre && (
                <Pill
                  label={`${evt.mitre.id} ¬∑ ${evt.mitre.name}`}
                  color="var(--slate)"
                />
              )}
            </div>
            <div className="event-meta">
              <span className="timestamp">{formatTime(evt.timestamp)}</span>
              {evt.beforeHash && (
                <span className="hash">Prev: {evt.beforeHash.slice(0, 10)}‚Ä¶</span>
              )}
              {evt.afterHash && (
                <span className="hash">New: {evt.afterHash.slice(0, 10)}‚Ä¶</span>
              )}
              {evt.severity && (
                <Pill label={evt.severity.toUpperCase()} color={severityHue[evt.severity]} />
              )}
            </div>
          </div>
        </div>
      );
    }

    function Toolbar({ baselineSize, onRebuild, status }) {
      const statusCopy = {
        streaming: 'Live feed active',
        ready: 'Loaded from API',
        connecting: 'Connecting‚Ä¶',
        disconnected: 'Stream disconnected',
        error: 'API unreachable'
      };
      return (
        <div className="toolbar">
          <div>
            <p className="toolbar-title">Secure baseline: {baselineSize} files</p>
            <p className="toolbar-sub">{statusCopy[status] || 'Monitoring'}</p>
          </div>
          <button className="btn" onClick={onRebuild}>Rebuild baseline</button>
        </div>
      );
    }

    function App() {
      const { events, status, counters, baselineSize, setBaselineSize } = useFimEvents();
      const [alert, setAlert] = useState('');

      const changesOverTime = useMemo(() => {
        const windowMs = 24 * 60 * 60 * 1000;
        const hourMs = 60 * 60 * 1000;
        const now = Date.now();
        const windowStart = now - windowMs;
        const buckets = Array.from({ length: 24 }, (_, idx) => {
          const bucketStart = windowStart + idx * hourMs;
          return {
            label: new Intl.DateTimeFormat('en', { hour: '2-digit', hour12: false }).format(
              new Date(bucketStart)
            ),
            counts: { create: 0, modify: 0, delete: 0 }
          };
        });

        events.forEach((evt) => {
          if (!evt.timestamp) return;
          const ts = new Date(evt.timestamp).getTime();
          if (Number.isNaN(ts) || ts < windowStart || ts > now) return;
          const idx = Math.min(Math.floor((ts - windowStart) / hourMs), buckets.length - 1);
          if (!buckets[idx]) return;
          if (evt.type === 'create' || evt.type === 'modify' || evt.type === 'delete') {
            buckets[idx].counts[evt.type] += 1;
          }
        });

        const maxTotal = Math.max(
          ...buckets.map((b) => Object.values(b.counts).reduce((sum, val) => sum + val, 0)),
          1
        );

        return { buckets, maxTotal };
      }, [events]);

      const rebuildBaseline = async () => {
        setAlert('Rebuilding baseline‚Ä¶');
        try {
          const res = await fetch('/api/rebuild', { method: 'POST' });
          const data = await res.json();
          setBaselineSize(data.baselineSize || 0);
          setAlert('Baseline rebuilt');
          setTimeout(() => setAlert(''), 2000);
        } catch (err) {
          setAlert('Failed to rebuild baseline');
        }
      };

      const latest = events[0];

      return (
        <main className="page">
          <header className="hero">
            <div>
              <p className="eyebrow">Real-time File Integrity Monitoring</p>
              <h1>Trust, but verify every file change</h1>
              <p className="lede">
                Watches a single critical directory, hashes every file, and streams create / modify / delete
                activity with context tied to MITRE ATT&CK-style tactics.
              </p>
              <div className="pill-row">
                <Pill label="Hashes are SHA-256" color="var(--slate)" />
                <Pill label="Governance filter skips personal data" color="var(--slate)" />
                <Pill label="Log integrity via append-only JSONL" color="var(--slate)" />
              </div>
            </div>
          </header>

          {alert && <div className="banner">{alert}</div>}

          <Toolbar baselineSize={baselineSize} onRebuild={rebuildBaseline} status={status} />

          <section className="grid">
            <StatCard title="Creates" value={counters.create} hint="New files in scope" />
            <StatCard title="Modifications" value={counters.modify} hint="Content tampering" />
            <StatCard title="Deletes" value={counters.delete} hint="Potential destruction" />
          </section>

          <section className="chart">
            <div className="chart-head">
              <div>
                <p className="eyebrow">Changes over time (last 24h)</p>
                <h2>Action mix by hour</h2>
              </div>
              <div className="legend">
                {Object.entries(actionColors).map(([type, color]) => (
                  <div className="legend-item" key={type}>
                    <span className="legend-swatch" style={{ backgroundColor: color }} />
                    <span className="legend-label">{type}</span>
                  </div>
                ))}
              </div>
            </div>
            <div className="chart-grid">
              {changesOverTime.buckets.map((bucket, idx) => {
                const total = Object.values(bucket.counts).reduce((sum, v) => sum + v, 0);
                return (
                  <div className="chart-bar" key={`${bucket.label}-${idx}`}>
                    <div className="bar-stack" aria-label={`Hour ${bucket.label}: ${total} changes`}>
                      {['create', 'modify', 'delete'].map((type) => {
                        const value = bucket.counts[type];
                        const height = (value / changesOverTime.maxTotal) * 100;
                        return (
                          <div
                            key={type}
                            className="bar-segment"
                            style={{
                              height: `${height}%`,
                              backgroundColor: actionColors[type],
                              opacity: value ? 1 : 0.3
                            }}
                            title={`${bucket.label}: ${type} ${value}`}
                          />
                        );
                      })}
                    </div>
                    <p className="chart-label">{bucket.label}</p>
                  </div>
                );
              })}
            </div>
          </section>

          {latest && (
            <section className="alert-card">
              <div className="alert-icon">{iconMap[latest.type] || '‚ö†Ô∏è'}</div>
              <div>
                <p className="alert-title">Most recent action</p>
                <p className="alert-body">{latest.message}</p>
                <p className="alert-meta">{formatTime(latest.timestamp)}</p>
              </div>
            </section>
          )}

          <section className="timeline">
            <div className="timeline-head">
              <h2>Timeline of actions</h2>
              <p className="timeline-sub">Showing up to 200 latest changes</p>
            </div>
            <div className="timeline-list">
              {events.map((evt) => (
                <EventRow evt={evt} key={evt.id} />
              ))}
              {!events.length && <p className="empty">No events yet. Touch a file in the watched folder.</p>}
            </div>
          </section>

          <section className="howto">
            <h3>Operational notes</h3>
            <ul>
              <li>Monitors the <code>watched/</code> directory. Update config in <code>server/index.js</code> if needed.</li>
              <li>Baseline hashes are stored at <code>data/baseline.json</code>. Use the rebuild button after trusted maintenance.</li>
              <li>Logs stream to <code>logs/fim.log</code> using JSON Lines to preserve integrity.</li>
            </ul>
          </section>
        </main>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
