<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Real-Time File Integrity Monitoring</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <div id="root"></div>

  <script type="module">
    const iconMap = {
      create: 'üü¢',
      modify: 'üü°',
      delete: 'üî¥',
      baseline: 'üìê'
    };

    const severityHue = {
      high: 'var(--red)',
      medium: 'var(--amber)',
      info: 'var(--green)'
    };

    const severityWeight = {
      high: 6,
      medium: 3,
      info: 1
    };

    const actionColors = {
      create: 'rgba(34, 197, 94, 0.9)',
      modify: 'rgba(245, 158, 11, 0.9)',
      delete: 'rgba(239, 68, 68, 0.9)'
    };

    const state = {
      events: [],
      status: 'connecting',
      baselineSize: 0,
      alert: ''
    };

    const formatTime = (ts) => new Intl.DateTimeFormat('en', {
      dateStyle: 'medium',
      timeStyle: 'medium'
    }).format(new Date(ts));

    const countersFromEvents = (events) => events.reduce(
      (acc, evt) => {
        if (evt.type === 'create' || evt.type === 'modify' || evt.type === 'delete') {
          acc[evt.type] = (acc[evt.type] || 0) + 1;
        }
        return acc;
      },
      { create: 0, modify: 0, delete: 0 }
    );

    function computeChangesOverTime(events) {
      const windowMs = 24 * 60 * 60 * 1000;
      const hourMs = 60 * 60 * 1000;
      const now = Date.now();
      const windowStart = now - windowMs;
      const totals = { create: 0, modify: 0, delete: 0 };
      const buckets = Array.from({ length: 24 }, (_, idx) => {
        const bucketStart = windowStart + idx * hourMs;
        return {
          label: new Intl.DateTimeFormat('en', { hour: '2-digit', hour12: false }).format(new Date(bucketStart)),
          counts: { create: 0, modify: 0, delete: 0 }
        };
      });

      events.forEach((evt) => {
        if (!evt.timestamp) return;
        const ts = new Date(evt.timestamp).getTime();
        if (Number.isNaN(ts) || ts < windowStart || ts > now) return;
        const idx = Math.min(Math.floor((ts - windowStart) / hourMs), buckets.length - 1);
        if (evt.type === 'create' || evt.type === 'modify' || evt.type === 'delete') {
          buckets[idx].counts[evt.type] += 1;
          totals[evt.type] += 1;
        }
      });

      const maxTotal = Math.max(
        ...buckets.map((b) => Object.values(b.counts).reduce((sum, val) => sum + val, 0)),
        1
      );

      return { buckets, maxTotal, totals };
    }

    function computeRisk(events) {
      const windowMs = 24 * 60 * 60 * 1000;
      const hourMs = 60 * 60 * 1000;
      const now = Date.now();
      const windowStart = now - windowMs;
      const buckets = Array.from({ length: 24 }, (_, idx) => {
        const bucketStart = windowStart + idx * hourMs;
        return {
          label: new Intl.DateTimeFormat('en', { hour: '2-digit', hour12: false }).format(new Date(bucketStart)),
          score: 0,
          actions: 0
        };
      });

      events.forEach((evt) => {
        if (!evt.timestamp || !evt.type) return;
        const ts = new Date(evt.timestamp).getTime();
        if (Number.isNaN(ts) || ts < windowStart || ts > now) return;
        const idx = Math.min(Math.floor((ts - windowStart) / hourMs), buckets.length - 1);
        const weight = severityWeight[evt.severity] || 1;
        const decay = Math.max(0.35, 1 - (now - ts) / windowMs);
        buckets[idx].score += weight * decay;
        buckets[idx].actions += 1;
      });

      const maxScore = Math.max(...buckets.map((b) => b.score), 1);
      const currentScore = buckets[buckets.length - 1]?.score || 0;
      const normalized = Math.min(Math.round((currentScore / maxScore) * 100), 100);
      let label = 'Low';
      let copy = 'Changes look routine with no concentrated destructive activity.';
      if (normalized >= 70) {
        label = 'Critical';
        copy = 'High-risk activity concentrated recently. Validate deletes and rebuild only if trusted.';
      } else if (normalized >= 40) {
        label = 'Elevated';
        copy = 'Steady medium/high severity actions. Review audit trail and confirm operators.';
      }

      return {
        buckets,
        maxScore,
        normalized,
        label,
        copy,
        currentScore
      };
    }

    function pill(label, color) {
      return `<span class="pill" style="background-color:${color}">${label}</span>`;
    }

    function renderEvent(evt) {
      const icon = iconMap[evt.type] || '‚ÑπÔ∏è';
      const mitre = evt.mitre ? pill(`${evt.mitre.id} ¬∑ ${evt.mitre.name}`, 'var(--slate)') : '';
      const severity = evt.severity ? pill(evt.severity.toUpperCase(), severityHue[evt.severity] || 'var(--slate)') : '';
      const ai = evt.aiAssessment || fallbackAiAssessment(evt);

      return `
        <div class="event-row">
          <div class="event-icon">${icon}</div>
          <div class="event-body">
            <div class="event-header">
              <div>
                <p class="event-title">${evt.message}</p>
                <p class="event-path">${evt.file || 'Baseline update'}</p>
              </div>
              ${mitre}
            </div>
            <div class="event-meta">
              <span class="timestamp">${formatTime(evt.timestamp)}</span>
              ${severity}
              <span class="ai-chip ai-${ai.label.toLowerCase()}">AI: ${ai.label} ¬∑ ${ai.score}</span>
            </div>
            ${renderHashTable(evt.beforeHash, evt.afterHash)}
            ${ai.reason ? `<p class="ai-reason">${ai.reason}</p>` : ''}
          </div>
        </div>`;
    }

    function renderHashTable(beforeHash, afterHash) {
      if (!beforeHash && !afterHash) return '';
      const prevValue = beforeHash ? `<span title="${beforeHash}">${beforeHash}</span>` : '‚Äî';
      const newValue = afterHash ? `<span title="${afterHash}">${afterHash}</span>` : '‚Äî';
      return `
        <div class="hash-table" role="table" aria-label="Previous and new hashes">
          <div class="hash-row hash-head" role="row"><span role="columnheader">Previous hash</span><span role="columnheader">New hash</span></div>
          <div class="hash-row" role="row"><span role="cell">${prevValue}</span><span role="cell">${newValue}</span></div>
        </div>`;
    }

    function fallbackAiAssessment(evt) {
      const severityScore = { high: 72, medium: 52, info: 28 };
      const base = severityScore[evt.severity] || 24;
      let label = 'Stable';
      if (base >= 70) label = 'Critical';
      else if (base >= 55) label = 'Elevated';
      else if (base >= 35) label = 'Watch';
      return { score: base, label, reason: 'derived from severity only' };
    }

    function renderLegend() {
      return Object.entries(actionColors).map(([type, color]) => `
        <div class="legend-item" key="${type}">
          <span class="legend-swatch" style="background-color:${color}"></span>
          <span class="legend-label">${type}</span>
        </div>
      `).join('');
    }

    function renderActionPie(model) {
      const total = Object.values(model.totals).reduce((sum, v) => sum + v, 0);
      if (!total) {
        return '<p class="empty">No changes in the last 24 hours.</p>';
      }

      const orders = ['create', 'modify', 'delete'];
      const toRadians = (pct) => (pct * Math.PI * 2) / 100;
      const arcPath = (start, end) => {
        const radius = 100;
        const sx = radius * Math.cos(start);
        const sy = radius * Math.sin(start);
        const ex = radius * Math.cos(end);
        const ey = radius * Math.sin(end);
        const large = end - start > Math.PI ? 1 : 0;
        return `M ${sx} ${sy} A ${radius} ${radius} 0 ${large} 1 ${ex} ${ey} L 0 0 Z`;
      };

      let cursor = -Math.PI / 2;
      const slices = orders.map((type) => {
        const value = model.totals[type] || 0;
        const pct = (value / total) * 100;
        const end = cursor + toRadians(pct);
        const path = arcPath(cursor, end);
        const mid = cursor + (end - cursor) / 2;
        cursor = end;
        const labelX = 115 * Math.cos(mid);
        const labelY = 115 * Math.sin(mid);
        return { type, value, pct, path, labelX, labelY };
      });

      const legend = slices.map((slice) => `
        <div class="legend-item">
          <span class="legend-swatch" style="background-color:${actionColors[slice.type]}"></span>
          <span class="legend-label">${slice.type} ¬∑ ${Math.round(slice.pct)}%</span>
          <span class="legend-count">(${slice.value})</span>
        </div>`).join('');

      const totalLabel = `${total} change${total === 1 ? '' : 's'} in 24h`;

      return `
        <div class="pie-wrap">
          <div class="pie-figure">
            <svg viewBox="-120 -120 240 240" role="img" aria-label="Action mix pie chart">
              ${slices.map((slice) => `
                <path d="${slice.path}" fill="${actionColors[slice.type]}" fill-opacity="0.88" stroke="rgba(0,0,0,0.25)" stroke-width="1" />
                <text x="${slice.labelX.toFixed(1)}" y="${slice.labelY.toFixed(1)}" fill="var(--text)" font-size="10" text-anchor="middle">${Math.round(slice.pct)}%</text>
              `).join('')}
              <circle r="45" fill="var(--card)" stroke="var(--border)" stroke-width="1" />
            </svg>
            <p class="pie-total">${totalLabel}</p>
          </div>
          <div class="pie-legend">${legend}</div>
        </div>`;
    }

    function renderHourlyChart(model) {
      return model.buckets.map((bucket) => {
        const total = Object.values(bucket.counts).reduce((sum, val) => sum + val, 0);
        const bars = ['create', 'modify', 'delete'].map((type) => {
          const value = bucket.counts[type] || 0;
          const pct = model.maxTotal ? (value / model.maxTotal) * 100 : 0;
          return `<div class="bar-segment" style="height:${pct}%; background:${actionColors[type]};" title="${bucket.label} ¬∑ ${type}: ${value}"></div>`;
        }).join('');

        return `
          <div class="chart-bar" aria-label="${bucket.label} changes">
            <div class="bar-stack" data-total="${total}">${bars}</div>
            <p class="chart-label">${bucket.label}</p>
          </div>`;
      }).join('');
    }

    function renderRiskChart(risk) {
      return risk.buckets.map((bucket, idx) => {
        const height = (bucket.score / risk.maxScore) * 100;
        return `
          <div class="risk-bar" title="Hour ${bucket.label}: risk score ${bucket.score.toFixed(1)}">
            <div class="risk-bar-fill" style="height:${height}%"></div>
            <p class="chart-label">${bucket.label}</p>
          </div>`;
      }).join('');
    }

    function render() {
      const counters = countersFromEvents(state.events);
      const changesOverTime = computeChangesOverTime(state.events);
      const riskModel = computeRisk(state.events);
      const latest = state.events[0];

      const statusCopy = {
        streaming: 'Live feed active',
        ready: 'Loaded from API',
        connecting: 'Connecting‚Ä¶',
        disconnected: 'Stream disconnected',
        error: 'API unreachable'
      };

      document.getElementById('root').innerHTML = `
        <main class="page">
          <header class="hero">
            <div>
              <p class="eyebrow">Real-time File Integrity Monitoring</p>
              <h1>Trust, but verify every file change</h1>
              <p class="lede">
                Watches a single critical directory, hashes every file, and streams create / modify / delete
                activity with context tied to MITRE ATT&CK-style tactics.
              </p>
              <div class="pill-row">
                ${pill('Hashes are SHA-256', 'var(--slate)')}
                ${pill('Governance filter skips personal data', 'var(--slate)')}
                ${pill('Log integrity via append-only JSONL', 'var(--slate)')}
              </div>
            </div>
          </header>

          ${state.alert ? `<div class="banner">${state.alert}</div>` : ''}

          <div class="toolbar">
            <div>
              <p class="toolbar-title">Secure baseline: ${state.baselineSize} files</p>
              <p class="toolbar-sub">${statusCopy[state.status] || 'Monitoring'}</p>
            </div>
            <button class="btn" id="rebuild-btn">Rebuild baseline</button>
          </div>

          <section class="grid">
            <div class="stat-card"><p class="stat-title">Creates</p><p class="stat-value">${counters.create}</p><p class="stat-hint">New files in scope</p></div>
            <div class="stat-card"><p class="stat-title">Modifications</p><p class="stat-value">${counters.modify}</p><p class="stat-hint">Content tampering</p></div>
            <div class="stat-card"><p class="stat-title">Deletes</p><p class="stat-value">${counters.delete}</p><p class="stat-hint">Potential destruction</p></div>
          </section>

          <section class="chart">
            <div class="chart-head">
              <div>
                <p class="eyebrow">Changes over time (last 24h)</p>
                <h2>Action mix</h2>
                <p class="chart-subtitle">Share of create / modify / delete events in the last 24 hours</p>
              </div>
              <div class="legend">${renderLegend()}</div>
            </div>
            <div class="chart-split">
              <div class="pie-area">
                <p class="chart-subtitle">Overall distribution</p>
                ${renderActionPie(changesOverTime)}
              </div>
              <div class="hourly-area">
                <div class="chart-head-sub">
                  <p class="eyebrow">Hourly breakdown</p>
                  <h3>Changes by hour</h3>
                  <p class="chart-subtitle">Stacked bars sized to the busiest hour</p>
                </div>
                <div class="chart-grid">${renderHourlyChart(changesOverTime)}</div>
              </div>
            </div>
          </section>

          <section class="risk-card">
            <div class="risk-head">
              <div>
                <p class="eyebrow">AI risk assessment</p>
                <h2>Behavioral risk outlook</h2>
                <p class="risk-sub">Weighted severity with recency decay across the last 24h.</p>
              </div>
              <div class="risk-chip risk-${riskModel.label.toLowerCase()}">
                <span class="risk-chip-score">${riskModel.normalized}</span>
                <span class="risk-chip-text">${riskModel.label}</span>
              </div>
            </div>
            <div class="risk-body">
              <div class="risk-summary">
                <p class="risk-score">${riskModel.normalized}</p>
                <p class="risk-label">${riskModel.label} risk</p>
                <p class="risk-copy">${riskModel.copy}</p>
              </div>
              <div class="risk-chart" role="img" aria-label="Risk score trend over last 24 hours">
                ${renderRiskChart(riskModel)}
              </div>
            </div>
          </section>

          ${latest ? `
            <section class="alert-card">
              <div class="alert-icon">${iconMap[latest.type] || '‚ö†Ô∏è'}</div>
              <div>
                <p class="alert-title">Most recent action</p>
                <p class="alert-body">${latest.message}</p>
                <p class="alert-meta">${formatTime(latest.timestamp)}</p>
              </div>
            </section>` : ''}

          <section class="timeline">
            <div class="timeline-head">
              <h2>Timeline of actions</h2>
              <p class="timeline-sub">Showing up to 200 latest changes</p>
            </div>
            <div class="timeline-list">
              ${state.events.map(renderEvent).join('') || '<p class="empty">No events yet. Touch a file in the watched folder.</p>'}
            </div>
          </section>

          <section class="howto">
            <h3>Operational notes</h3>
            <ul>
              <li>Monitors the <code>watched/</code> directory. Update config in <code>server/index.js</code> if needed.</li>
              <li>Baseline hashes are stored at <code>data/baseline.json</code>. Use the rebuild button after trusted maintenance.</li>
              <li>Logs stream to <code>logs/fim.log</code> using JSON Lines to preserve integrity.</li>
            </ul>
          </section>
        </main>`;

      const rebuildBtn = document.getElementById('rebuild-btn');
      if (rebuildBtn) {
        rebuildBtn.addEventListener('click', async () => {
          state.alert = 'Rebuilding baseline‚Ä¶';
          render();
          try {
            const res = await fetch('/api/rebuild', { method: 'POST' });
            const data = await res.json();
            state.baselineSize = data.baselineSize || 0;
            state.alert = 'Baseline rebuilt';
          } catch (err) {
            state.alert = 'Failed to rebuild baseline';
          }
          setTimeout(() => {
            state.alert = '';
            render();
          }, 2000);
        });
      }
    }

    async function loadInitial() {
      try {
        const res = await fetch('/api/events');
        const data = await res.json();
        state.events = data.events || [];
        state.baselineSize = data.baselineSize || 0;
        state.status = 'ready';
      } catch (err) {
        state.status = 'error';
      }
      render();
    }

    function startStream() {
      const source = new EventSource('/stream');
      source.onopen = () => { state.status = 'streaming'; render(); };
      source.onerror = () => { state.status = 'disconnected'; render(); };
      source.onmessage = (evt) => {
        const payload = JSON.parse(evt.data);
        if (!payload.type || payload.type === 'connected') return;
        state.events.unshift(payload);
        state.events = state.events.slice(0, 200);
        render();
      };
    }

    loadInitial().then(startStream);
  </script>
</body>
</html>
